목차

[toc]

---

# 1. 알고리즘

## 1) 의미

- 문제를 해결하기  위한 자세한 방법

  좋은  알고리즘이란? 두가지 문제를  충족해야함

  ​	첫째. 문제를  해결하는 것

  ​	둘째. 문제를 더 잘  해결하는 것



## 2) 선형  탐색(linear search algorithm)

* 처음부터 차례대로  탐색을 하는 알고리즘
* 선형 탐색은 값이  없을때 상당히 많은 데이터를 거쳐야 하므로 비효율 적일 수 있음.



## 3) 이진  탐색(binary search algorithm)

* 중간을 기준으로  찾을 값이 해당하는 쪽만 남기고 나머지는 버림.
* 남아있는 값 중  또다시 중간을 기준으로 이전과 같은 방법으로 찾기를 진행함.
* 이진 탐색은 값이  정렬되어 있을때만 사용 가능한 알고리즘이므로 정렬되어 있지 않은 값은 선형 탐색을 사용해야함.



## 4) 정렬

### a. 선택정렬(selection sort)

* 가장 자연스러운  정렬 알고리즘. 작은값->큰값
* 0번 인덱스부터 끝  인덱스까지 차례대로 값을 확인해보고, 가장 작은 인덱스의 값을 처음 인덱스 값과 바꾸어줌

### b. 삽입정렬(insertion sort)

* 값을 올바른 위치에  삽입시켜 정렬함.

*알고리즘을  공부할때: 시간과 공간을  신경써야함. 좋은 코드의 첫번째  기준은 시간임. 공간은 컴퓨터의  저장공간(메모리를 최대한 적게 사용해야함)



# 2. 시간복잡도(time complexity)

데이터가 많아질수록  걸리는 시간이 얼마나 급격히 증가하는지 나타내는 개념

시간복잡도를  계산하는데는 수학적인 개념을 이해해야함. (거듭제곱과 로그)

### a. 거듭제곱(exponentiation)

### b. 로그(logarithms)

### c. 점근  표기법(Big-O notation)

* big-O of  n 이라고 읽음.
* 가장 영향력이  있는 n을 표기함



# 3. 재귀함수(recursive  function)

자기 자신을  호출하는 함수

재귀함수로  팩토리얼(fatorial)을 다루는 함수를 만드려면 재귀적으로 만들 수 있음.

재귀적으로 문제를  푼다는 것은 같은 형태의 더 작은 문제(부분 문제 혹은 subproblem)를 풀고, 부분문제의 답을 이용해서 원래 문제를 풀어야함



## 1) base  case and recursive case

* n = 0인 경우  n! = 1

* n > 0인  경우 n! = n * (n - 1)!

  *항상 base  case와 recursive case 모두를 생각해야함



## 2) 반복문 vs  재귀함수

* 재귀함수는 call  stack(컴퓨터가 임의로 저장해 놓은 바로 이전의 함수 데이터)이 많이 쌓이면 stack overflow error가 발생하게 됨.

  따라서 재귀함수를  사용할 때 call stack이 많이 발생하는 경우라면 반복문을 사용해야함.