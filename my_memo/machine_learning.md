[toc]

# 1. 머신러닝 종류

* 지도학습: 문제에 대한 답을 가르쳐줌(스팸메일)
* 비지도학습: 답이 없고 답을 유추해냄

# 2. k-최근접 이웃 알고리즘(kNN)

* 가장 가까운 이웃 데이터 k개를 찾음.
* k는 그냥 자연수
* 더 많은 데이터가 있을수록 신뢰가 있기 때문에 머신러닝이라고 할 수 있음

# 3. 머신러닝 기본 수학

## 1) 선형대수학

* 일차함수를 사용함

$$
f(x_0,x_1...x_n)=a_0x_0+a_1x_1+...+a_nx_n+b
$$

* 위와 C:\Users\Ramie\codeit\test.py C:\Users\Ramie\codeit\test2.py같이 계수와 변수들을 x0, x2 로 사용함. 마지막 상수항은 b

## 2) 행렬과 벡터

### a. 행렬

* 행렬 = 메트릭스
* 직사각형 모양의 행과 열
* A 라는 행렬 안의 각각의 수를 원소라고 부름
* 주로 대문자 알파벳을 씀

### b. 벡터

* 행이 하나밖에 없거나 열이 하나밖에 없는 행렬
* 열이 하나면 열 벡터, 행이 하나면 행 벡터
* 열 벡터를 사용하는 경우가 훨씬 많음.
* 백터의 차원은 원소 개수로 얘기함. 열백터의 원소가 5개면 5차원의 열 벡터
* 주로 소문자 알파벳을 씀

$$
a_1 =a의 첫번째원소
$$

# 4. numpy 행렬 사용

```python
import numpy as np

A = np.array([
    [1, -1, 2],
    [2, 3, 6]
])

B = np.array([[ 0, 1],
              [ 1, 4],
              [ 5, 2]])

C = np.random.rand(3, 5)  # 0 - 1 범위의 랜덤 숫자로 3행 5열을 채워줌

D = np.zeros((2, 4))  # 0으로 행렬을 채우려면 괄호를 하나 더 추가 해야함

print(A)
print(B)
print(C)
print(D)
```

# 5. 행렬 연산

## 1) 행렬 덧셈

* 같은 위치의 원소끼리 더함. 두 행렬의 차원이 같아야함

```python
import numpy as np

A = np.array([
    [1, 1],
    [2, 3]
])

B = np.array([
    [3, 2],
    [6, 2]
])

print(A + B)
# [[4 3]
# [8 5]]
```

## 2) 행렬 곱셈

* 스칼라 곱(선형 대수에서는 행렬이 아닌 일반 수를 스칼라 라고 함)

```python
import numpy as np

i = 5

A = np.array([
    [1, 4],
    [2, 3]
])

print(i * A) # 각 원소에 i(5)를 곱해주면 됨
# [[ 5 20]
#  [10 15]]
```

## 3) 두 행렬의 곱

### a. 내적곱

* A의 열 수와 B의 행 수가 같아야 함(원소 개수가 같아야함)
* A = m x n 행렬, B = n x p 행렬일때 AB = m x p 행렬이 나옴
* 교차 법칙 성립 X (AB != BA)

```python
A = np.array([
    [1, 3, 1],
    [2, 2, 1]
])

B = np.array([
    [5, 6],
    [4, 2],
    [3, 1]
])

# AB = [
#     [1 * 5 + 3 * 4 + 1 * 3, 1 * 6 + 3 * 2 + 1 * 1]
#     [2 * 5 + 2 * 4 + 1 + 3, 2 * 6 + 2 * 2 + 1 * 1]
# ]

# AB = [
#     [20, 13]
#     [21, 17]
# ]
```

### b. 요소별 곱하기(Element-wise Multiplication)

* 행렬 덧셈 연산과 거의 똑같은 성질을 갖음(행렬의 수가 같을 때)
* 곱셈 표기를 동그라미(o)를 써서 표현(A o B)
