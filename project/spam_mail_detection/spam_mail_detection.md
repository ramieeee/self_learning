**스팸메일 필터링**

[toc]

# 1. 배경 연구

## 1) 메일 서버 구축

1. DNS 서버
2. MX 레코드
3. Vmware 로컬 메일 서버 구축 공부 (postfix)

### a. 환경

* VMware
* CentOS7 64bit
* Windows 10 64bit
* postfix
* dovecot

## 2) 스팸 메일 차단 기술

- RBM 기술? 자연어 처리?

## 3) 결론

* 어떤점이 현 기술에 문제가 있는지 파악하고 대안 기법 확인 필요

# 2. 학습 파라미터

* 인간이 어떤 부분에서 메일을 스팸으로 분류하는지 확인해야함
* 메일 헤더, 내용, 메일이 어떻게 작동하는지 공부

# 3. 네임서버 구축

* mail.project.com(스팸 피해자) = 192.168.100.142
* mail.test.com(스팸 발신자) = 192.168.100.140
* DNS = 192.168.100.143

```
yum -y install bind bind-chroot
```

```
vim /etc/hosts

# project.com 서버
192.168.100.142 mail.project.com

# test.com 서버
192.168.100.140 mail.test.com
```

```
vim /etc/sysconfig/network

# project.com 서버
HOSTNAME=192.168.100.142

# test.com 서버
HOSTNAME=192.168.100.140
```

```
# DNS
vim /etc/named.conf

options {

# 나의 어떤 IP와 포트로 청취할 것인가의 옵션
listen-on port 53 { any; };

# 위 옵션과 같이 IPv6 의 IP 와 포트를 청취할 것인지 설정
listen-on-v6 port 53 { none; };

# 어떤 IP한테서의 쿼리를 허용할 것인지 설정
allow-query { any; };
};

dnssec-validation no;

# zone 설정
zone "project.com" IN {
        type master;
        file "project.com.db";
        allow-update { none; };
};

zone "test.com" IN {
        type master;
        file "test.com.db";
        allow-update { none; };
};
```

```
vi /var/named/project.com.db

$TTL    3H
@       SOA     @       root.   ( 2  1D  1H  1W  1H )
        IN      NS      @
        IN      A       192.168.100.142
        IN      MX      10      mail.project.com.

mail    IN      A       192.168.100.142
```

```
vi /var/named/test.com.db

$TTL    3H
@       SOA     @       root.   ( 2  1D  1H  1W  1H )
        IN      NS      @
        IN      A       192.168.100.140
        IN      MX      10      mail.test.com.

mail    IN      A       192.168.100.140
```

```
# 적용이 잘 되었는지 확인
named-checkconf
named-checkzone project.com project.com.db
named-checkzone test.com test.com.db
```

```
# 서비스 시작
systemctl restart named
systemctl enable named
```

```
# 방화벽 내리기
systemctl stop firewalld
systemctl disable firewalld
```

```
# nameserver 작동 확인
nslookup
> server 192.168.100.143
Default server: 192.168.100.143
Address: 192.168.100.143#53
> mail.project.com
Server:		192.168.100.143
Address:	192.168.100.143#53

Name:	mail.project.com
Address: 192.168.100.142
> mail.test.com
Server:		192.168.100.143
Address:	192.168.100.143#53

Name:	mail.test.com
Address: 192.168.100.140
```

```
# 각 서버에서 DNS 설정

# project.com, test.com 서버
nmcli con mod ens33 ipv4.dns 192.168.100.143
systemctl restart NetworkManager
reboot
```



# 4. 메일 서버 구축

* 참고자료

4. https://erider.co.kr/127 <- 메일 명령어 관련 블로그
5. https://cghsecurity.tistory.com/15?category=907152 <- 네임서버 구축
3. https://www.youtube.com/watch?v=iFMnYUvBqEA&list=PLVsNizTWUw7EJ9z-LW3lv3VC-6HI9I3hN&index=52 <- sendmail 서버 구축

## 1) sendmail 구축

```
yum -y install sendmail-cf dovecot
```

```
vim /etc/mail/sendmail.cf

# project.com 서버
85 Cwproject.com
264 O DaemonPortOptions=Port=smtp, Name=MTA

# test.com 서버
85 Cwtest.com
264 O DaemonPortOptions=Port=smtp, Name=MTA
```

```
# RELAY 메일 전달하는 기능 추가
vim /etc/mail/access

# project.com, test.com 서버
project.com     RELAY
test.com        RELAY
192.168.100     RELAY

# 두 서버 모두에서 설정한 내용 적용
makemap hash /etc/mail/access < /etc/mail/access
```

```
# 두 서버 모두
vim /etc/dovecot/conf.d/10-ssl.conf
8: ssl = yes
```

```
vim /etc/dovecot/conf.d/10-mail.conf

# 주석 해제
25 mail_location = mbox:~/mail:INBOX=/var/mail/%u
121 mail_access_groups = mail
166 lock_method = fcntl
```

```
systemctl restart sendmail
systemctl enable sendmail
```

# 5. Spamassassin 설치

## 1)

```
yum -y install spamassassin
```

```
# Mailbox 로 전송되기 전에 spamassassin 이 처리하도록 설정
vim /etc/procmailrc

# 아래 내용 추가
INCLUDERC=/etc/mail/spamassassin/spamassassin-default.rc
```

```
# spamassassin 설정

cd /etc/mail/spamassassin
vim local.cf

# 새 줄 추가
required_score 5
```

```
# spamassassin이 기본적으로 root 계정으로 실행되기때문에 실행 그룹 추가

groupadd -g 5555 spamd
useradd -u 5555 -g spamd -s /bin/false -d /var/log/spamassassin spamd
chown spamd:spamd /var/log/spamassassin
```

```
systemctl restart spamassassin
systemctl enable spamassassin
```

## 2)

```
# 계정 설치
useradd -M -s /bin/false -c “SpamAssassin Operator” spamd

cat /etc/passwd | grep spamd
spamd:x:540:540:SpamAssassin Operator:/free/home/spamd:/bin/false

cat /etc/shadow | grep spamd
spamd:!!:14692:0:99999:7:::
```

```
[root@ns1 ~]# cd /etc/mail/spamassassin/

기존 파일은 백업을 해두고 새로 local.cf 파일을 생성한다

[root@ns1 spamassassin]# mv local.cf local.cf.old

[root@ns1 spamassassin]# vi local.cf

# SpamAssassin config file for version 3.x
# NOTE: NOT COMPATIBLE WITH VERSIONS 2.5 or 2.6
# See http://www.yrex.com/spam/spamconfig25.php for earlier versions
# Generated by http://www.yrex.com/spam/spamconfig.php (version 1.50)
# How many hits before a message is considered spam.
required_score           5.0

# Change the subject of suspected spam
rewrite_header subject         [SPAM]

# Encapsulate spam in an attachment (0=no, 1=yes, 2=safe)
report_safe             0

# Enable the Bayes system
use_bayes               1

# Enable Bayes auto-learning
#bayes_auto_learn              1

# Enable or disable network checks
skip_rbl_checks         0
use_razor2              0
use_dcc                 0
use_pyzor               1

# Mail using languages used in these country codes will not be marked
# as being possibly spam in a foreign language.
# – korean
ok_languages            all

# Mail using locales used in these country codes will not be marked
# as being possibly spam in a foreign language.
ok_locales              all
```

```
# MDA가 사용할 procmailrc 파일을 생성
vi /etc/procmailrc

DROPPRIVS=yes
#SpamAssassin Procmail Start
#
:0fw: spamassassin.lock
* < 256000
|spamc -u $LOGNAME
#SpamAssassin End
```

```
#!/usr/bin/env python

# spamcheck.py: spam tagging support for Postfix/Cyrus
#
# Copyright (C) 2002, 2003 James Henstridge
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# Spam Assassin filter to fit in between postfix (or other MTA) and
# Cyrus IMAP (or other MDA).  To hook it up, simply copy the
# spamcheck.py and spamd.py files to postfix's libexec directory and
# add a line like the following to postfix's master.cf:
#
# spamcheck	unix	-	n	n	-	-	pipe
#     flags=R user=cyrus
#     argv=/usr/libexec/postfix/spamcheck.py -s ${sender} -r ${user} -l unix:/...
#
# then in main.cf, set the mailbox_transport to spamcheck.  A copy of
# spamcheck will be started for each incomming message.  The spamcheck
# script will contact the IMAP server's LMTP socket to check whether
# the user exists, get spamd to process the message and then pass the
# message to the IMAP server.

import sys
import re, getopt
import smtplib, socket
import spamd

# exit statuses taken from <sysexits.h>
EX_OK       = 0
EX_USAGE    = 64
EX_DATAERR  = 65
EX_NOUSER   = 67
EX_TEMPFAIL = 75

# this class hacks smtplib's SMTP class into a shape where it will
# successfully pass a message off to Cyrus's LMTP daemon.
# Also adds support for connecting to a unix domain socket.
class LMTP(smtplib.SMTP):
    lhlo_resp = None
    def __init__(self, host=''):
        self.lmtp_features  = {}
        self.esmtp_features = self.lmtp_features

        if host:
            (code, msg) = self.connect(host)
            if code != 220:
                raise smtplib.SMTPConnectError(code, msg)

    def connect(self, host='localhost'):
        """Connect to a host on a given port.

        If the hostname starts with `unix:', the remainder of the string
        is assumed to be a unix domain socket.
        """

        if host[:5] == 'unix:':
            host = host[5:]
            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            if self.debuglevel > 0: print 'connect:', host
            self.sock.connect(host)
        else:
            port = LMTP_PORT
            if ':' in host:
                hose, port = host.split(':', 1)
                port = int(port)
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            if self.debuglevel > 0: print 'connect:', (host, port)
            self.sock.connect((host, port))
        (code, msg) = self.getreply()
        if self.debuglevel > 0: print 'connect:', msg
        return (code, msg)

    def lhlo(self, name='localhost'):
        """ LMTP 'lhlo' command.
        Hostname to send for this command defaults to localhost.
        """
        self.putcmd("lhlo",name)
        (code, msg) = self.getreply()
        if code == -1 and len(msg) == 0:
            raise smtplib.SMTPServerDisconnected("Server not connected")
        self.lhlo_resp = msg
        self.ehlo_resp = msg
        if code != 250:
            return (code, msg)
        self.does_esmtp = 1
        # parse the lhlo response
        resp = self.lhlo_resp.split('\n')
        del resp[0]
        for each in resp:
            m = re.match(r'(?P<feature>[A-Za-z0-9][A-Za-z0-9\-]*)',each)
            if m:
                feature = m.group("feature").lower()
                params = m.string[m.end("feature"):].strip()
                self.lmtp_features[feature] = params
        return (code, msg)

    # make sure bits of code that tries to EHLO actually LHLO instead
    ehlo = lhlo

def process_message(spamd_host, lmtp_host, sender, recipient):
    try:
        lmtp = LMTP(lmtp_host)
    except:
        sys.exit(EX_TEMPFAIL)
    #lmtp.set_debuglevel(2)
    code, msg = lmtp.lhlo()
    if code != 250: sys.exit(EX_TEMPFAIL)

    # connect to the LMTP server
    code, msg = lmtp.mail(sender)
    if code != 250: sys.exit(1)
    code, msg = lmtp.rcpt(recipient)
    if code == 550: sys.exit(EX_NOUSER)
    if code != 250: sys.exit(EX_TEMPFAIL)

    # read in the first chunk of the message
    CHUNKSIZE = 256 * 1024
    data = sys.stdin.read(CHUNKSIZE)

    # if data is less than chunk size, check it
    if len(data) < CHUNKSIZE:
        connection = spamd.SpamdConnection(spamd_host)
        connection.addheader('User', recipient)
        try:
            connection.check(spamd.PROCESS, data)
            data = connection.response_message
        except spamd.error, e:
            sys.stderr.write('spamcheck: %s' % str(e))

    # send the data in chunks
    lmtp.putcmd("data")
    code, msg = lmtp.getreply()
    if code != 354: sys.exit(EX_TEMPFAIL)
    lmtp.send(smtplib.quotedata(data))
    
    data = sys.stdin.read(CHUNKSIZE)
    while data != '':
        lmtp.send(smtplib.quotedata(data))
        data = sys.stdin.read(CHUNKSIZE)
    lmtp.send('\r\n.\r\n')
 
    code, msg = lmtp.getreply()
    if code != 250: sys.exit(EX_TEMPFAIL)

def main(argv):
    spamd_host = ''
    lmtp_host = None
    sender = None
    recipient = None
    try:
        opts, args = getopt.getopt(argv[1:], 's:r:l:')
    except getopt.error, err:
        sys.stderr.write('%s: %s\n' % (argv[0], err))
        sys.exit(EX_USAGE)
    for opt, arg in opts:
        if opt == '-s': sender = arg
        elif opt == '-r': recipient = arg.lower()
        elif opt == '-l': lmtp_host = arg
        else:
            sys.stderr.write('unexpected argument\n')
            sys.exit(EX_USAGE)
    if args:
        sys.stderr.write('unexpected argument\n')
        sys.exit(EX_USAGE)
    if not lmtp_host or not sender or not recipient:
        sys.stderr.write('required argument missing\n')
        sys.exit(EX_USAGE)

    try:
        process_message(spamd_host, lmtp_host, sender, recipient)
    except SystemExit:
        raise # let SystemExit through ...
    except:
        sys.stderr.write('%s: %s\n' % sys.exc_info()[:2])
        sys.exit(1)

if __name__ == '__main__':
    main(sys.argv)
```

## 3)

```
yum install spamassassin
yum install python-pytest
yum install spamassassin_client
```

```
# example

import os

from spamassassin_client import SpamAssassin

FILES = [dict(type='spam', name='sample-spam.txt'),
	 dict(type='ham', name='sample-nonspam.txt')]

def main():

    path = os.path.dirname(__file__)
    for test in FILES:
	filename = os.path.join(path, test['name'])
	with open(filename,"rb") as f:            
	    print("\nProcessing file: {}".format(filename))
	    assassin = SpamAssassin(f.read())
	    print(assassin)
	    if assassin.is_spam():
	        print("The received message is considered spam with a score of {0}".format(assassin.get_score()))
	    print('\nreport_fulltext:', assassin.get_fulltext())
	    print('score:', assassin.get_score())
	    print('report_json:', assassin.get_report_json())

if __name__ == "__main__":
    main()
```

```
# run test
pytest -v
```

